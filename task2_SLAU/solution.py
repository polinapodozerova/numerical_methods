# -*- coding: utf-8 -*-
"""2zadanie.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DOLFPLoyUfC6k6FlNN64cFPvTM6AY4qX
"""

import numpy as np
import pandas as pd
from math import sqrt
from copy import deepcopy

"""*Функции для работы с матрицами:*"""

def transpose(mtx):
    m = [[0 for i in range(len(mtx))] for j in range(len(mtx[0]))]
    for i in range(len(mtx)):
        for j in range(len(mtx[0])):
            m[j][i] = mtx[i][j]
    return m


def create(n, m):
    mtx = [[]*m] * n
    for k in range(n):
        mtx[k] = [float(j) for j in input().split()]
    return mtx


def new_blank(n, m):
    return [[0 for i in range(n)] for j in range(m)]


def show(mtx):
    for k in range(len(mtx)):
        print(*mtx[k])


def rank(mtx, rows, cols):
    p = min(rows, cols)
    res = 0
    for j in range(p):
        if not_zero(mtx[j][j]): res += 1
    return res


def swap_rows(mtx, row_1, row_2):
    mtx[row_1], mtx[row_2] = mtx[row_2], mtx[row_1]
    return mtx


def not_zero(a):
    if abs(a) < 0.001: return False
    return True


def change_zeros(mtx):
    m = len(mtx)
    r2 = 1
    for i in range(m):
        if abs(mtx[i][i]) < 0.00001:
            swap_rows(mtx, i, r2)
        else:
            r2 = i
    return mtx


def multiply(m1, m2):
    m = [[0 for i in range(len(m2[0]))] for j in range(len(m1))]
    for i in range(len(m1)):
        for j in range(len(m2[0])):
            for k in range(len(m2)):
                m[i][j] += m1[i][k]*m2[k][j]
    return m


def multiply_v(m1, m2):
    m = [0 for j in range(len(m1))]
    for i in range(len(m1)):
        for k in range(len(m2)):
            m[i] += m1[i][k]*m2[k]
    return m


def norma(vec):
    return sum(vec)


def norm_2(a):
    return sqrt(sum([i * i for i in a]))


def subtract(v1, v2):
    v = [0 for i in range(len(v1))]
    for i in range(len(v1)):
        v[i] = v1[i] - v2[i]
    return v


def subtract_m(m1, m2):
    m = [[0 for i in range(len(m1[0]))] for j in range(len(m1))]
    for i in range(len(m1)):
        for j in range(len(m1[0])):
            m[i][j] = m1[i][j] - m2[i][j]
    return m

def add(v1, v2):
    v = [0 for i in range(len(v1))]
    for i in range(len(v1)):
        v[i] = v1[i] + v2[i]
    return v

def change_rows_to_max(mtx):
    for i in range(len(mtx)):
        p = mtx[i][i]
        index = i
        for j in range(index, len(mtx)):
            if mtx[j][i] > p:
                index = j
                p = mtx[j][i]
        mtx[i], mtx[j] = mtx[j], mtx[i]
    return mtx

def norm_row(A):
    summax = 0
    for i in range(len(A)):
        summ = 0
        for j in range(len(A[0])):
            summ += abs(A[i][j])
        if summ > summax:
            summax = summ
    return(summax)


def norm_col(A):
    summ = 0
    summax = 0
    for i in range(len(A[0])):
        if summ > summax:
            summax = summ
        summ = 0
        for j in range(len(A)):
            summ += abs(A[j][i])
    if summ > summax:
        summax = summ
    return(summax)


def ones(n):
    m = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        m[i][i] = 1
    return m


def multiply_digit(m, a):
    for i in range(len(m)):
        for j in range(len(m[0])):
            m[i][j] *= a
    return m

def multiply_digit_v(m, a):
    for i in range(len(m)):
        m[i] *= a
    return m


def vect_to_mat(a):
    n = len(a)
    m = [[0 for i in range(n)] for j in  range(n)]
    for i in range(n):
        for j in range(n):
            m[i][j] = a[i]*a[j]
    return m

def generate_last_test(n, N, eps):
    m = [[0 for i in range(n + 1)] for j in range(n)]
    for i in range(n):
        for j in range(n):
            if i == j: m[i][j] = 1 + eps * N
            elif j < i : m[i][j] = eps * N
            else : m[i][j] = -1 - eps * N
        m[i][-1] = -1
    m[-1][-1] = 1
    return(m)

def create_ident(n):
    m = [[0 for i in range(n)] for i in range(n)]
    for i in range(n):
        m[i][i] = 1
    return m

def vect_y(n, R):
    y = [0] * n
    if len(R) == n:
        for i in range(n):
            y[i] = R[i][0]
    else:
        for i in range(n):
            y[i] = R[i + (len(R) - n)][len(R) - n]
    return y


def vect_w(y, z):
    a = norm_2(y)
    p = norm_2([y[i] - z[i]*a for i in range(len(z))] )

    w1 = [(y[i] - z[i] * a)/p for i in range(len(z))]
    return w1

def Q_n(Q, n):
    Q_ = [[0 for i in range(n)] for j in range(n)]
    for i in range(n - len(Q)):
        Q_[i][i] = 1
    for i in range(n - (n - len(Q))):
        for j in range(n - (n - len(Q))):
            Q_[n - len(Q) + i][n - len(Q) + j] = Q[i][j]
    return Q_

def R_n(R, n, s):
    R_ = [[0 for i in range(n)] for j in range(n)]
    for i in range(n):
        for j in range(n):
            R_[i][j] = R[s + i][s + j]
    return R_

def Rn(R, R_):
    n = len(R)
    d = len(R) - len(R_)
    A = [[0 for i in range(n)] for j in range(n)]
    for i in range(d):
        for j in range(n):
            A[i][j] = R[i][j]
    for i in range(len(R_)):
        for j in range(d):
            A[i + d][j] = R[i + d][j]
        for j in range(len(R_)):
            A[i + d][j + d] = R_[i][j]
    return A

def lead_el(A, P, k):
    max_el = abs(A[k][k])
    st = k
    for i in range(k + 1, len(A)):
        if max_el < abs(A[i][k]):
            max_el = A[i][k]
            st = i
    if st != k:
        for i in range(0, len(A)):
            A[st][i], A[k][i] = A[k][i], A[st][i]
            P[st][i], P[k][i] = P[k][i], P[st][i]
    return A, P

"""*Метод Зейделя:*"""

def solve_seidel(A, b, eps, old_A, old_b):

    n = len(A)
    x = [0] * n
    c = new_blank(n, n)
    d = []

    for i in range(n):
        d.append(b[i] / A[i][i])
        for j in range(n):
            if i == j:
                c[i][j] = 0
            else:
                c[i][j] = -A[i][j] / A[i][i] if A[i][j] != 0 else 0

    ready = False
    iters = 0
    while not ready:
        iters += 1
        for i in range(n):
            x[i] = sum([c[i][j]*x[j] for j in range(n)]) + d[i]
        ready = norm_2(subtract(multiply_v(old_A, x), old_b)) <= eps

    #x = [round(i, 9) for i in x]
    return x, iters

"""*Метод простой итерации:*"""

def solve_simplit(A, b, eps, old_A, old_b):

    n = len(A)
    mu = 1/norm_col(A)
    B = subtract_m(ones(n), multiply_digit(A, 1/norm_col(A)))
    f = False
    norm_B = norm_col(B)
    if norm_B >= 1:
        B = transpose(B)
        norm_B = norm_col(B)
        if norm_B >= 1:
            f = True

    c = [b[i]*mu for i in range(n)]
    x0 = c
    x1 = [0 for i in range(n)]
    for i in range(n):
        x1[i] = sum([B[i][j]*x0[j] for j in range(n)]) + c[i]
    def uslov(norm_B):
        if f: return False
        p = abs(norm_B) / (1 - norm_B)
        Z = p * sum([abs(x1[i] - x0[i]) for i in range(n)])
        if Z >= eps:
            return True
        return False

    iters = 0
    while uslov(norm_B) or (f and sum([abs(i) for i in subtract(multiply_v(old_A, x1), old_b)]) >= eps):
        x0 = x1.copy()
        iters += 1
        for i in range(n):
            x1[i] = sum([B[i][j] * x0[j] for j in range(n)]) + c[i]

    #x1 = [round(i, 9) for i in x1]
    return x1, iters

"""*Метод Гаусса (LU – разложение):*"""

def solve_lup(A, b):

    n = len(A)

    E = create_ident(n)
    P = create_ident(n)

    for k in range(n - 1):
        A, P = lead_el(A, P, k)
        t = A[k][k]
        for i in range(k + 1, n):
            for j in range(k, n):
                if j == k:
                    A[i][j] = A[i][j] / t
                else:
                    A[i][j] = A[i][j] - A[i][k] * A[k][j]

    L = [[0 for i in range(n)] for j in range(n)]
    U = [[0 for i in range(n)] for j in range(n)]

    for i in range(n):
        for j in range(n):
            if i == j:
                U[i][j] = A[i][j]
                L[i][j] = 1
            elif i > j:
                L[i][j] = A[i][j]
            else:
                U[i][j] = A[i][j]

    Pb = multiply_v(P, b)

    Y = [0] * n
    Y[0] = Pb[0]
    for i in range(1, n):
        Y_t = Pb[i]
        for j in range(i):
            Y_t -= L[i][j] * Y[j]
        Y[i] = Y_t

    x = [0 for i in range(n)]
    x[n - 1] = Y[n - 1] / U[n - 1][n - 1]
    for i in range(1, n):
        x_t = Y[n - 1 - i]
        for j in range(i):
            x_t = x_t - U[n - i - 1][n - j - 1] * x[n - j - 1]
        x[n - i - 1] = x_t / U[n - 1 - i][n - 1 - i]
    #x = [round(i, 9) for i in x]
    return x

"""*Метод Отражений (QR – разложение (метод Хаусхолдера)):*"""

def solve_qr(A, b):
    n = len(A)
    Q = create_ident(n)
    R = deepcopy(A)

    for i in range(n - 1):
        y = vect_y(n - i, R)
        z = [0 for i in range(n - i)]
        z[0] = 1
        E = create_ident(n - i)

        w = vect_w(y, z)
        Q_ = subtract_m(E, multiply_digit(vect_to_mat(w), 2))
        if len(Q_) != len(R):
            R_ = R_n(R, len(Q_), i)
        else:
            R_ = R
        R_ = multiply(Q_, R_)
        if len(Q_) != n:
            Q_ = Q_n(Q_, n)
        if len(R_) != n:
            R = Rn(R, R_)
        else:
            R = R_
        Q = multiply(Q_, Q)

    Y = multiply_v(Q, b)

    x = [0] * n
    x[n - 1] = Y[n - 1]/R[n - 1][n - 1]
    for i in range(1, n):
        x_t = Y[n - 1 - i]
        for j in range(i):
            x_t = x_t - R[n - i - 1][n - j - 1] * x[n - j - 1]
        x[n - i - 1] = x_t / R[n - 1 - i][n - 1 - i]
    #x = [round(i, 9) for i in x]
    return x

"""*Вычисление истинных значений с использованием numpy:*"""

def check(A, b): 
        b = np.array(b)
        A = np.array(A)
        x = np.linalg.solve(A, b)
        x = np.round(x, 5)
        return x

"""*Вычисление значений для таблицы для тестов 0-4:*"""

table = []
with open("tests.txt", "r") as file:
    k = 0
    f=True
    while f:
                n = int(file.readline())
                if not n or n == 0:
                    f = False
                    break
                b = []
                A = []
                matrix = []
                for i in range(n):
                    matrix.append([float(j) for j in file.readline().split()])
                for i in range(n):
                    if matrix[i][i] == 0:
                        matrix = change_rows_to_max(matrix)

                for s in matrix:
                    b.append(s[-1])
                    A.append(s[:-1])

                true_x = check(A, b)

                t_A = multiply(transpose(A), A)
                t_b = multiply_v(transpose(A), b)

                for eps in [(10)**i for i in range(-2, -5, -1)]:

                    mpi_x, mpi_iter_num = solve_simplit(deepcopy(t_A), deepcopy(t_b), eps, deepcopy(A), deepcopy(b))
                    mpi_delta = norm_2(true_x - mpi_x)
                    seidel_x, seidel_iter_num = solve_seidel(deepcopy(t_A), deepcopy(t_b), eps, deepcopy(A), deepcopy(b))
                    seidel_delta = norm_2(true_x - seidel_x)
                    gauss_x = solve_lup(deepcopy(A), deepcopy(b))
                    gauss_delta = norm_2(true_x - gauss_x)
                    house_x = solve_qr(deepcopy(A), deepcopy(b))
                    house_delta = norm_2(true_x - house_x)

                    #округление
                    p = 9
                    seidel_x = [round(i, p) for i in seidel_x]
                    mpi_x = [round(i, p) for i in mpi_x]
                    gauss_x = [round(i, p) for i in gauss_x]
                    house_x = [round(i, p) for i in house_x]
                    table.append([k, true_x, eps, mpi_x, mpi_delta, mpi_iter_num, seidel_x, seidel_delta, seidel_iter_num, gauss_x, gauss_delta, house_x, house_delta])

                k+=1

df = pd.DataFrame(table, columns=['test_num', 'x_true', 'eps', 'mpi_x', 'mpi_delta', 'mpi_iter_num', 'seidel_x', 'seidel_delta', 'seidel_iter_num', 'gauss_x', 'gauss_delta', 'house_x', 'house_delta'])

"""*Заполнение таблицы в файле excel:*"""

writer = pd.ExcelWriter('output1.xlsx')

df.to_excel(writer)
writer.save()

table5 = []
with open("tests5.txt", "r") as file:

    f=True
    while f:
                n = int(file.readline())
                eps5 = float(file.readline())
                if not n or n == 0:
                    f = False
                    break
                b = []
                A = []
                matrix = []
                for i in range(n):
                    matrix.append([float(j) for j in file.readline().split()])
                for i in range(n):
                    if matrix[i][i] == 0:
                        matrix = change_rows_to_max(matrix)

                for s in matrix:
                    b.append(s[-1])
                    A.append(s[:-1])

                true_x = check(A, b)

                t_A = multiply(transpose(A), A)
                t_b = multiply_v(transpose(A), b)

                for eps in [10**(i-1) for i in range(-2, -5, -1)]:

                    mpi_x, mpi_iter_num = solve_simplit(deepcopy(t_A), deepcopy(t_b), eps, deepcopy(A), deepcopy(b))
                    mpi_delta = norm_2(true_x - mpi_x)
                    seidel_x, seidel_iter_num = solve_seidel(deepcopy(t_A), deepcopy(t_b), eps, deepcopy(A), deepcopy(b))
                    seidel_delta = norm_2(true_x - seidel_x)
                    gauss_x = solve_lup(deepcopy(A), deepcopy(b))
                    gauss_delta = norm_2(true_x - gauss_x)
                    house_x = solve_qr(deepcopy(A), deepcopy(b))
                    house_delta = norm_2(true_x - house_x)

                    #округление
                    p = 9
                    seidel_x = [round(i, p) for i in seidel_x]
                    mpi_x = [round(i, p) for i in mpi_x]
                    gauss_x = [round(i, p) for i in gauss_x]
                    house_x = [round(i, p) for i in house_x]
                    table5.append([n, eps5, true_x, eps*10, mpi_x, mpi_delta, mpi_iter_num, seidel_x, seidel_delta, seidel_iter_num, gauss_x, gauss_delta, house_x, house_delta])

df5 = pd.DataFrame(table5, columns=['dimension', 'eps', 'x_true', 'e', 'mpi_x', 'mpi_delta', 'mpi_iter_num', 'seidel_x', 'seidel_delta', 'seidel_iter_num', 'gauss_x', 'gauss_delta', 'house_x', 'house_delta'])

writer5 = pd.ExcelWriter('output5.xlsx')

df5.to_excel(writer5)
writer5.save()
